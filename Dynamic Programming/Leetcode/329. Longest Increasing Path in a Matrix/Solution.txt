/*
   
   suppose we travel from one point to another ... and it is increasing then if we encounter same path any later time it will also be increasing 
   so we just calculate that part and store in dp ...
   
   9 9 4  dp = 1 1 1
   6 6 8       2 1 2
   2 1 1       3 4 1   -> we  wil return max ans possible from this    
*/

class Solution {
public:
    int x , y;
    
    int maxm(int& a,  int& b, int & c, int& d)
    {
        return max(max(a,b),max(c,d));
    }
    
    int dp[201][201];
    
    int recurr(vector<vector<int>>& m , int i , int j , vector<vector<bool>>& visited , int prev)
    {
        if(i<0 || j< 0 || i==x || j==y || visited[i][j] || prev >= m[i][j] )
            return 0;
        
        if(dp[i][j] != -1)
            return dp[i][j];
        
        dp[i][j] = 1;
        
        int a = recurr(m,i+1,j,visited,m[i][j]);
        int b = recurr(m,i,j+1,visited,m[i][j]);
        int c = recurr(m,i-1,j,visited,m[i][j]);
        int d = recurr(m,i,j-1,visited,m[i][j]);
        
        dp[i][j] += maxm(a,b,c,d);
        
        return dp[i][j];
    }
    
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        
         x = matrix.size() ;
         y = matrix[0].size();
        
        memset(dp,-1,sizeof(dp));
        
        int ans = 0;
        
        for(int i=0;i<x;i++)
        {
            for(int j=0;j<y;j++)
            {
                if(dp[i][j] != -1)
                    continue;
                
                vector<vector<bool>>visited(x,vector<bool>(y,false));
                ans  = max(ans ,recurr(matrix , i , j ,visited , -1));
            }
         
        }
        
       
        return ans;

        
    }
};
